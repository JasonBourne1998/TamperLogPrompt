import re
from typing import List, Tuple, Callable, Literal
# try:
#     import openai as OpenAI
#     import openai
# except:
from openai import OpenAI
from openai.types.chat import ChatCompletion

from .prompt import *
from .tester import Tester
from .logger import user, agent

class GPTChecker:
    def __init__(
            self,
            api_key: str,
            model: Literal["gpt-4o"],
            top_p: float,
            max_tokens: int,
            temperature: float,
            turns: int = 3
        ) -> None:
        """
        GPT-based constraint checker for: (1) database, (2) input, (3) flow, and (4) commonsense contraints.

        Args:
            api_key: OpenAI secret key
            model: OpenAI model name
            top_p: The threshold probability mass for nucleus sampling
            max_tokens: The maximum number of tokens that can be generated
            temperature: The sampling temperature to use
            turns: The maximum number of turns before giving up
        """
        self.client = OpenAI(api_key=api_key)
        self.model = model
        self.model_args = {
            "top_p": top_p,
            "max_tokens": max_tokens,
            "temperature": temperature
        }
        self.turns = turns

    @user
    def check_input_constraint(
        self,
        class_name1: str,
        class_name2: str,
        class_definition1: str,
        class_definition2: str,
        logs: list[str]
    ):
        """
        Identify attribute relationships between two classes [A] and [B]

        Args:
            class_definition1: full definition of class [A]
            class_definition2: full definition of class [B]

        Return:
            solved: code successfully passes all test cases
            code: the final constraint checking function generated by GPT
        """
        task = INPUT_CONSTRAINT_USER.format(
            class_definition1=class_definition1,
            class_definition2=class_definition2,
            logs="\n".join([f"\t[{i}] {log}" for i, log in enumerate(logs)])
        )

        messages = [
            {"role": "system", "content": INPUT_CONSTRAINT_SYSTEM},
            {"role": "user", "content": task}
        ]

        for _ in range(self.turns):
            response = self._generate(messages)
            thought, code = self._parse_response(response)

            exec(code, globals())
            target_function: Callable = globals()["is_related"]

            passed, fails, reasons = Tester.test_input_constraint(
                logs,
                class_name1,
                class_name2,
                target_function
            )
            if passed: break

            feedback = COMMONSENSE_CONSTRAINT_FEEDBACK.format(
                fails=len(reasons),
                reasons="\n".join([f"\t[{i}] {reason}" for i, reason in enumerate(reasons)])
            )
            messages = []
            messages.append({"role": "assistant", "content": response})
            messages.append({"role": "user", "content": feedback})

        return passed, code
    
    @user
    def check_database_constraint(
        self,
        class_name: str,
        class_definition: str,
        logs1: list[str],
        logs2: list[str]
    ):
        """
        Identify consistency of object instance at event 1 and event 2.

        Args:
            class_name: class name of target object
            class_definition: class definition of target object
            logs_1: logs generated at event 1 containing instances of object
            logs_2: logs generated at event 2 containing instances of object

        Return:
            solved: code successfully passes all test cases
            code: the final constraint checking function generated by GPT
        """
        task = DATABASE_CONSTRAINT_USER.format(
            class_name=class_name,
            class_definition=class_definition,
            logs1="\n".join([f"\t[{i}] {log}" for i, log in enumerate(logs1)]),
            logs2="\n".join([f"\t[{i}] {log}" for i, log in enumerate(logs2)])
        )

        messages = [
            {"role": "system", "content": DATABASE_CONSTRAINT_SYSTEM},
            {"role": "user", "content": task}
        ]

        for _ in range(self.turns):
            response = self._generate(messages)
            thought, code = self._parse_response(response)

            exec(code, globals())
            target_function: Callable = globals()["is_consistent"]

            passed, fails, reasons = Tester.test_database_constraint(
                logs1,
                logs2,
                class_name,
                target_function
            )
            if passed: break

            feedback = DATABASE_CONSTRAINT_FEEDBACK.format(
                fails=len(reasons),
                reasons="\n".join([f"\t[{i}] {reason}" for i, reason in enumerate(reasons)])
            )
            messages = []
            messages.append({"role": "assistant", "content": response})
            messages.append({"role": "user", "content": feedback})

        return passed, code

    @user
    def check_flow_constraint(
        self,
        parent_url: str,
        child_url1: str,
        child_url2: str,
        logs1: list[str],
        logs2: list[str]
    ):
        """
        Identify the rules that causes control flow to branch from [A] to [B]

        Args:
            parent_url: the URL endpoint of service used right before branching
            child_url1: the URL endpoint of service used right after branching to [A]
            child_url2: the URL endpoint of service used right after branching to [B]
            logs1: the application logs generated going from parent_url -> child_url1 [A]
            logs2: the application logs generated going from parent_url -> child_url2 [B]

        Return:
            solved: code successfully passes all test cases
            code: the final constraint checking function generated by GPT
        """
        passed, code = False, None
        task = FLOW_CONSTRAINT_USER.format(
            parent_url=parent_url,
            child_url1=child_url1,
            child_url2=child_url2,
            logs1="\n".join([f"\t[A{i}] {log}" for i, log in enumerate(logs1)]),
            logs2="\n".join([f"\t[B{i}] {log}" for i, log in enumerate(logs2)]),
        )
        messages = [{"role": "system", "content": FLOW_CONSTRAINT_SYSTEM}]
        messages.append({"role": "user", "content": task})

        for _ in range(self.turns):
            response = self._generate(messages)
            thought, code = self._parse_response(response)

            exec(code, globals())
            is_branch_a: Callable = globals().get("is_branch_a")
            is_branch_b: Callable = globals().get("is_branch_b")

            if not is_branch_a or not is_branch_b:
                raise ValueError("Generated code did not contain 'is_branch_a' or 'is_branch_b'")

            passed1, fails1, reasons1 = Tester.test_flow_constraint(logs1, [True] * len(logs1), is_branch_a)
            passed2, fails2, reasons2 = Tester.test_flow_constraint(logs2, [False] * len(logs2), is_branch_b)
            passed = passed1 and passed2
            reasons = reasons1 + reasons2
            if passed: break

            feedback = FLOW_CONSTRAINT_FEEDBACK.format(
                fails=len(reasons1 + reasons2),
                reasons="\n".join([f"\t[{i}] {reason}" for i, reason in enumerate(reasons)])
            )
            messages.append({"role": "assistant", "content": response})
            messages.append({"role": "user", "content": feedback})

        return passed, code

    @user
    def check_data_relationship(
        self,
        logs: str,
        traces: str
    ):
        """
        Identify data flow relationships between APIs

        Args:
            logs: the combined logs

        Return:
            edges
        """
        task = DATA_RELATIONSHIP_USER.format(logs=logs,traces=traces)
        messages = [
            {"role": "system", "content": DATA_RELATIONSHIP_SYSTEM},
            {"role": "user", "content": task}
        ]
        response = self._generate(messages)

        thought_pattern = r"<thought>(.*)<\/thought>"
        edge_pattern = r"<edge>(.*)<\/edge>"

        thought = re.findall(thought_pattern, response, re.DOTALL)[0]
        edges = re.findall(edge_pattern, response)

        return True, edges
    
    @user
    def check_trigger_relationship(
        self,
        traces: str,
        code: str
    ):
        """
        Identify trigger relationships between APIs

        Args:
            code: the combined frontend source code containing the API calls.

        Return:
            triggers
        """
        task = TRIGGER_RELATIONSHIP_USER.format(traces=traces,code=code)
        messages = [
            {"role": "system", "content": TRIGGER_RELATIONSHIP_SYSTEM},
            {"role": "user", "content": task}
        ]
        response = self._generate(messages)

        thought_pattern = r"<thought>(.*)<\/thought>"
        trigger_pattern = r"<trigger>(.*)<\/trigger>"

        thought = re.findall(thought_pattern, response, re.DOTALL)[0]
        triggers = re.findall(trigger_pattern, response, re.DOTALL)

        return True, triggers

    @user
    def check_commonsense_constraint(
        self,
        class_name: str,
        class_definition: str,
        logs: list[str]
    ):
        """
        Identify the data validation rules for all attributes in a class

        Args:
            class_name: the target class
            class_definition: the full definition of class
            logs: the application logs generated containing instances of this class

        Return:
            passed: code successfully passes all test cases
            code: the final constraint checking function generated by GPT
        """
        passed, code = False, None
        task = COMMONSENSE_CONSTRAINT_USER.format(
            class_definition=class_definition,
            logs="\n".join([f"\t[{i}] {log}" for i, log in enumerate(logs)])
        )
        messages = [{"role": "system", "content": COMMONSENSE_CONSTRAINT_SYSTEM}]
        messages.append({"role": "user", "content": task})

        for _ in range(self.turns):
            response = self._generate(messages)
            thought, code = self._parse_response(response)

            exec(code, globals())
            target_function: Callable = globals()["is_valid"]

            passed, fails, reasons = Tester.test_commonsense_contraint(
                logs, 
                class_name,
                target_function
            )
            if passed: break

            feedback = COMMONSENSE_CONSTRAINT_FEEDBACK.format(
                fails=len(reasons),
                reasons="\n".join([f"\t[{i}] {reason}" for i, reason in enumerate(reasons)])
            )
            messages.append({"role": "assistant", "content": response})
            messages.append({"role": "user", "content": feedback})

        return passed, code
    
    @agent
    def _generate(self, messages: list[dict[str, str]]) -> str:
        """
        Generate response from GPT.

        Args:
            messages: current interaction trajectory

        Return:
            response
        """
        response: ChatCompletion = self.client.chat.completions.create(
            model=self.model,
            messages=messages,
            **self.model_args
        )
        response = response.choices[0].message.content
        return response

    def _parse_response(self, response: str) -> tuple[str, str]:
        """
        Parse LLM response to get thought and executable code

        Args:
            response: full response from GPT

        Return:
            thought: GPT's step-by-step plan enclosed in <thought> tags
            code: GPT's proposed code solution
        """
        response = response.replace(";", "\n")

        # Matches both ```code``` and ```python code```and captures the `code` part. It uses a non-greedy match for the content inside.
        code_pattern = r"```(?:\w+\s+)?(.*?)```"

        # Matches content enclosed by <thought> tags.
        thought_pattern = r"<thought>(.*)<\/thought>"

        # Find all non-overlapping matches in the string
        # The regex captures the content inside the triple backticks.
        # The `re.DOTALL` flag allows the dot `.` to match newline characters as well,
        # so the code inside backticks can span multiple lines.
        code = re.findall(code_pattern, response, re.DOTALL)[0]
        thought = ""
        try:
            thought = re.findall(thought_pattern, response, re.DOTALL)[0]
        except:
            pass
        return thought, code
    
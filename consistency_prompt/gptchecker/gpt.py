import re
from typing import Literal, Callable

from openai import OpenAI
from openai.types.chat import ChatCompletion

from .prompt import *
from .tester import Tester
from .logger import user, agent

class GPTChecker:
    def __init__(
            self,
            api_key: str,
            model: Literal["gpt-4o"],
            top_p: float,
            max_tokens: int,
            temperature: float,
            turns: int = 5
        ) -> None:
        """
        GPT-based constraint checker for: (1) database, (2) input, (3) flow, and (4) commonsense contraints.

        Args:
            api_key: OpenAI secret key
            model: OpenAI model name
            top_p: The threshold probability mass for nucleus sampling
            max_tokens: The maximum number of tokens that can be generated
            temperature: The sampling temperature to use
            turns: The maximum number of turns before giving up
        """
        self.client = OpenAI(api_key=api_key)
        self.model = model
        self.model_args = {
            "top_p": top_p,
            "max_tokens": max_tokens,
            "temperature": temperature
        }
        self.turns = turns

    @user
    def check_input_constraint(
        self,
        class_name1: str,
        class_name2: str,
        class_definition1: str,
        class_definition2: str,
        logs: list[str]
    ):
        """
        Identify attribute relationships between two classes [A] and [B]

        Args:
            class_definition1: full definition of class [A]
            class_definition2: full definition of class [B]

        Return:
            solved: code successfully passes all test cases
            code: the final constraint checking function generated by GPT
        """
        task = INPUT_CONSTRAINT_USER.format(
            class_definition1=class_definition1,
            class_definition2=class_definition2,
            logs="\n".join([f"\t[{i}] {log}" for i, log in enumerate(logs)])
        )

        messages = [
            {"role": "system", "content": INPUT_CONSTRAINT_SYSTEM},
            {"role": "user", "content": task}
        ]

        for _ in range(self.turns):
            response = self._generate(messages)
            thought, code = self._parse_response(response)

            exec(code, globals())
            target_function: Callable = globals()["is_related"]

            passed, fails, reasons = Tester.test_input_constraint(
                logs,
                class_name1,
                class_name2,
                target_function
            )
            if passed: break

            feedback = COMMONSENSE_CONSTRAINT_FEEDBACK.format(
                fails=len(reasons),
                reasons="\n".join([f"\t[{i}] {reason}" for i, reason in enumerate(reasons)])
            )

            messages.append({"role": "assistant", "content": response})
            messages.append({"role": "user", "content": feedback})

        return passed, code

    @user
    def check_flow_constraint(
        self,
        parent_url: str,
        child_url1: str,
        child_url2: str,
        logs1: list[str],
        logs2: list[str]
    ):
        """
        Identify the rules that causes control flow to branch from [A] to [B]

        Args:
            parent_url: the URL endpoint of service used right before branching
            child_url1: the URL endpoint of service used right after branching to [A]
            child_url2: the URL endpoint of service used right after branching to [B]
            logs1: the application logs generated going from parent_url -> child_url1 [A]
            logs2: the application logs generated going from parent_url -> child_url2 [B]

        Return:
            solved: code successfully passes all test cases
            code: the final constraint checking function generated by GPT
        """
        passed, code = False, None
        task = FLOW_CONSTRAINT_USER.format(
            parent_url=parent_url,
            child_url1=child_url1,
            child_url2=child_url2,
            logs1="\n".join([f"\t[A{i}] {log}" for i, log in enumerate(logs1)]),
            logs2="\n".join([f"\t[B{i}] {log}" for i, log in enumerate(logs2)]),
        )
        messages = [{"role": "system", "content": FLOW_CONSTRAINT_SYSTEM}]
        messages.append({"role": "user", "content": task})

        for _ in range(self.turns):
            response = self._generate(messages)
            thought, code = self._parse_response(response)

            exec(code, globals())
            target_function: Callable = globals()["is_branch_a"]

            passed1, fails1, reasons1 = Tester.test_flow_constraint(logs1, [True] * len(logs1), target_function)
            passed2, fails2, reasons2 = Tester.test_flow_constraint(logs2, [False] * len(logs2), target_function)
            passed = passed1 & passed2
            reasons = reasons1 + reasons2
            if passed: break

            feedback = FLOW_CONSTRAINT_FEEDBACK.format(
                fails=len(reasons1 + reasons2),
                reasons="\n".join([f"\t[{i}] {reason}" for i, reason in enumerate(reasons)])
            )
            messages.append({"role": "assistant", "content": response})
            messages.append({"role": "user", "content": feedback})

        return passed, code

    @user
    def check_commonsense_constraint(
        self,
        class_name: str,
        class_definition: str,
        logs: list[str]
    ):
        """
        Identify the data validation rules for all attributes in a class

        Args:
            class_name: the target class
            class_definition: the full definition of class
            logs: the application logs generated containing instances of this class

        Return:
            passed: code successfully passes all test cases
            code: the final constraint checking function generated by GPT
        """
        passed, code = False, None
        task = COMMONSENSE_CONSTRAINT_USER.format(
            class_definition=class_definition,
            logs="\n".join([f"\t[{i}] {log}" for i, log in enumerate(logs)])
        )
        messages = [{"role": "system", "content": COMMONSENSE_CONSTRAINT_SYSTEM}]
        messages.append({"role": "user", "content": task})

        for _ in range(self.turns):
            response = self._generate(messages)
            thought, code = self._parse_response(response)

            exec(code, globals())
            target_function: Callable = globals()["is_valid"]

            passed, fails, reasons = Tester.test_commonsense_contraint(
                logs, 
                class_name,
                target_function
            )
            if passed: break

            feedback = COMMONSENSE_CONSTRAINT_FEEDBACK.format(
                fails=len(reasons),
                reasons="\n".join([f"\t[{i}] {reason}" for i, reason in enumerate(reasons)])
            )
            messages.append({"role": "assistant", "content": response})
            messages.append({"role": "user", "content": feedback})

        return passed, code
    
    @agent
    def _generate(self, messages: list[dict[str, str]]) -> str:
        """
        Generate response from GPT.

        Args:
            messages: current interaction trajectory

        Return:
            response
        """
        response: ChatCompletion = self.client.chat.completions.create(
            model=self.model,
            messages=messages,
            **self.model_args
        )
        response = response.choices[0].message.content
        return response

    def _parse_response(self, response: str) -> tuple[str, str]:
        """
        Parse LLM response to get thought and executable code

        Args:
            response: full response from GPT

        Return:
            thought: GPT's step-by-step plan enclosed in <thought> tags
            code: GPT's proposed code solution
        """
        response = response.replace(";", "\n")

        # Matches both ```code``` and ```python code```and captures the `code` part. It uses a non-greedy match for the content inside.
        code_pattern = r"```(?:\w+\s+)?(.*?)```"

        # Matches content enclosed by <thought> tags.
        thought_pattern = r"<thought>(.*)<\/thought>"

        # Find all non-overlapping matches in the string
        # The regex captures the content inside the triple backticks.
        # The `re.DOTALL` flag allows the dot `.` to match newline characters as well,
        # so the code inside backticks can span multiple lines.
        code = re.findall(code_pattern, response, re.DOTALL)[0]
        thought =re.findall(thought_pattern, response, re.DOTALL)[0]

        return thought, code
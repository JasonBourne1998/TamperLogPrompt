{
    "auth.service.impl.TokenServiceImpl.getToken": "import re\n\ndef is_valid(instance: dict) -> bool:\n    # Validate username\n    username = instance.get('username')\n    if username is not None:\n        if not isinstance(username, str):\n            raise ValueError(\"Username must be a string.\")\n        if not re.match(r'^[a-zA-Z0-9_.]+$', username):\n            raise ValueError(\"Username must contain only alphanumeric characters, underscores, or dots.\")\n        if not (3 <= len(username) <= 30):\n            raise ValueError(\"Username must be between 3 and 30 characters long.\")\n    \n    # Validate password\n    password = instance.get('password')\n    if password is not None:\n        if not isinstance(password, str):\n            raise ValueError(\"Password must be a string.\")\n        if len(password) < 6:\n            raise ValueError(\"Password must be at least 6 characters long.\")\n    \n    # Validate verificationCode\n    verificationCode = instance.get('verificationCode')\n    if verificationCode is not None:\n        if not (isinstance(verificationCode, str) or isinstance(verificationCode, int)):\n            raise ValueError(\"Verification code must be a string or an integer.\")\n        if isinstance(verificationCode, str) and not re.match(r'^\\d{4}$', verificationCode):\n            raise ValueError(\"Verification code must be a 4-digit number if it is a string.\")\n        if isinstance(verificationCode, int) and not (1000 <= verificationCode <= 9999):\n            raise ValueError(\"Verification code must be a 4-digit number if it is an integer.\")\n    \n    return True\n\n",
    "preserveOther.service.PreserveOtherServiceImpl.preserve": "from uuid import UUID\nfrom datetime import datetime\nimport re\ndef is_valid(instance: dict) -> bool:\n    try:\n        if not isinstance(instance.get('accountId'), str) or not instance['accountId']:\n            raise ValueError(\"accountId must be a non-empty string\")\n        if not isinstance(instance.get('contactsId'), str) or not instance['contactsId']:\n            raise ValueError(\"contactsId must be a non-empty string\")\n        if not isinstance(instance.get('tripId'), str) or not instance['tripId']:\n            raise ValueError(\"tripId must be a non-empty string\")\n        if not isinstance(instance.get('seatType'), int):\n            raise ValueError(\"seatType must be an integer\")\n        if instance.get('loginToken') is not None and not isinstance(instance['loginToken'], str):\n            raise ValueError(\"loginToken must be a string or None\")\n        if not isinstance(instance.get('date'), str) or not instance['date']:\n            raise ValueError(\"date must be a non-empty string\")\n        if not isinstance(instance.get('from'), str) or not instance['from']:\n            raise ValueError(\"from must be a non-empty string\")\n        if not isinstance(instance.get('to'), str) or not instance['to']:\n            raise ValueError(\"to must be a non-empty string\")\n        if not isinstance(instance.get('assurance'), int):\n            raise ValueError(\"assurance must be an integer\")\n        if not isinstance(instance.get('foodType'), int):\n            raise ValueError(\"foodType must be an integer\")\n        if instance.get('stationName') is not None and not isinstance(instance['stationName'], str):\n            raise ValueError(\"stationName must be a string or None\")\n        if instance.get('storeName') is not None and not isinstance(instance['storeName'], str):\n            raise ValueError(\"storeName must be a string or None\")\n        if instance.get('foodName') is not None and not isinstance(instance['foodName'], str):\n            raise ValueError(\"foodName must be a string or None\")\n        if not isinstance(instance.get('foodPrice'), (int, float)) or instance['foodPrice'] < 0:\n            raise ValueError(\"foodPrice must be a non-negative float\")\n        if instance.get('handleDate') is not None and not isinstance(instance['handleDate'], str):\n            raise ValueError(\"handleDate must be a string or None\")\n        if instance.get('consigneeName') is not None and not isinstance(instance['consigneeName'], str):\n            raise ValueError(\"consigneeName must be a string or None\")\n        if instance.get('consigneePhone') is not None and not isinstance(instance['consigneePhone'], str):\n            raise ValueError(\"consigneePhone must be a string or None\")\n        if not isinstance(instance.get('consigneeWeight'), (int, float)) or instance['consigneeWeight'] < 0:\n            raise ValueError(\"consigneeWeight must be a non-negative float\")\n        if isinstance(instance.get('isWithin'), bool):\n            raise ValueError(\"isWithin must be a boolean\")\n\n        # Format Check\n        try:\n            UUID(instance['accountId'])\n        except ValueError:\n            raise ValueError(\"accountId must be a valid UUID\")\n        \n        try:\n            UUID(instance['contactsId'])\n        except ValueError:\n            raise ValueError(\"contactsId must be a valid UUID\")\n        \n        try:\n            datetime.strptime(instance['date'], '%Y-%m-%d')\n        except ValueError:\n            raise ValueError(\"date must be in the format YYYY-MM-DD\")\n        \n        if instance.get('handleDate'):\n            try:\n                datetime.strptime(instance['handleDate'], '%Y-%m-%d')\n            except ValueError:\n                raise ValueError(\"handleDate must be in the format YYYY-MM-DD\")\n\n        if instance.get('consigneeName') and not re.match(r'^[a-zA-Z0-9\\s\\.\\,\\-\\_]+$', instance['consigneeName']):\n            raise ValueError(\"consigneeName must be a string of digits\")\n\n        if instance.get('consigneePhone') and not re.match(r'^\\d+$', instance['consigneePhone']):\n            raise ValueError(\"consigneePhone must be a string of digits\")\n\n        # Range Check\n        if not (1 <= instance['seatType'] <= 3):\n            raise ValueError(\"seatType must be between 1 and 3\")\n\n        return True\n\n    except KeyError as e:\n        raise ValueError(f\"Missing required field: {e}\")",
    "preserve.service.PreserveServiceImpl.preserve": "from uuid import UUID\nfrom datetime import datetime\nimport re\ndef is_valid(instance: dict) -> bool:\n    try:\n        if not isinstance(instance.get('accountId'), str) or not instance['accountId']:\n            raise ValueError(\"accountId must be a non-empty string\")\n        if not isinstance(instance.get('contactsId'), str) or not instance['contactsId']:\n            raise ValueError(\"contactsId must be a non-empty string\")\n        if not isinstance(instance.get('tripId'), str) or not instance['tripId']:\n            raise ValueError(\"tripId must be a non-empty string\")\n        if not isinstance(instance.get('seatType'), int):\n            raise ValueError(\"seatType must be an integer\")\n        if instance.get('loginToken') is not None and not isinstance(instance['loginToken'], str):\n            raise ValueError(\"loginToken must be a string or None\")\n        if not isinstance(instance.get('date'), str) or not instance['date']:\n            raise ValueError(\"date must be a non-empty string\")\n        if not isinstance(instance.get('from'), str) or not instance['from']:\n            raise ValueError(\"from must be a non-empty string\")\n        if not isinstance(instance.get('to'), str) or not instance['to']:\n            raise ValueError(\"to must be a non-empty string\")\n        if not isinstance(instance.get('assurance'), int):\n            raise ValueError(\"assurance must be an integer\")\n        if not isinstance(instance.get('foodType'), int):\n            raise ValueError(\"foodType must be an integer\")\n        if instance.get('stationName') is not None and not isinstance(instance['stationName'], str):\n            raise ValueError(\"stationName must be a string or None\")\n        if instance.get('storeName') is not None and not isinstance(instance['storeName'], str):\n            raise ValueError(\"storeName must be a string or None\")\n        if instance.get('foodName') is not None and not isinstance(instance['foodName'], str):\n            raise ValueError(\"foodName must be a string or None\")\n        if not isinstance(instance.get('foodPrice'), (int, float)) or instance['foodPrice'] < 0:\n            raise ValueError(\"foodPrice must be a non-negative float\")\n        if instance.get('handleDate') is not None and not isinstance(instance['handleDate'], str):\n            raise ValueError(\"handleDate must be a string or None\")\n        if instance.get('consigneeName') is not None and not isinstance(instance['consigneeName'], str):\n            raise ValueError(\"consigneeName must be a string or None\")\n        if instance.get('consigneePhone') is not None and not isinstance(instance['consigneePhone'], str):\n            raise ValueError(\"consigneePhone must be a string or None\")\n        if not isinstance(instance.get('consigneeWeight'), (int, float)) or instance['consigneeWeight'] < 0:\n            raise ValueError(\"consigneeWeight must be a non-negative float\")\n        if isinstance(instance.get('isWithin'), bool):\n            raise ValueError(\"isWithin must be a boolean\")\n\n        # Format Check\n        try:\n            UUID(instance['accountId'])\n        except ValueError:\n            raise ValueError(\"accountId must be a valid UUID\")\n        \n        try:\n            UUID(instance['contactsId'])\n        except ValueError:\n            raise ValueError(\"contactsId must be a valid UUID\")\n        \n        try:\n            datetime.strptime(instance['date'], '%Y-%m-%d')\n        except ValueError:\n            raise ValueError(\"date must be in the format YYYY-MM-DD\")\n        \n        if instance.get('handleDate'):\n            try:\n                datetime.strptime(instance['handleDate'], '%Y-%m-%d')\n            except ValueError:\n                raise ValueError(\"handleDate must be in the format YYYY-MM-DD\")\n\n        if instance.get('consigneeName') and not re.match(r'^[a-zA-Z0-9\\s\\.\\,\\-\\_]+$', instance['consigneeName']):\n            raise ValueError(\"consigneeName must be a string of digits\")\n\n        if instance.get('consigneePhone') and not re.match(r'^\\d+$', instance['consigneePhone']):\n            raise ValueError(\"consigneePhone must be a string of digits\")\n\n        # Range Check\n        if not (1 <= instance['seatType'] <= 3):\n            raise ValueError(\"seatType must be between 1 and 3\")\n\n        return True\n\n    except KeyError as e:\n        raise ValueError(f\"Missing required field: {e}\")",
    "order.service.OrderServiceImpl.queryOrdersForRefresh": "import re\ndef is_valid(instance: dict) -> bool:    \n    uuid_regex = re.compile(r'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')\n    if instance.get('loginId') and not uuid_regex.match(instance['loginId']):\n        raise ValueError(\"Invalid loginId: {instance['loginId']}\")    \n    if instance.get('state') is not None and not isinstance(instance['state'], int):\n        raise ValueError(\"State must be an integer: {instance['state']}\")\n    if instance.get('enableStateQuery') and instance.get('state') is not None:\n        if not (0 <= instance['state'] <= 10): \n            raise ValueError(\"State must be between 0 and 10: {instance['state']}\")\n    return True\n",
    "other.service.OrderOtherServiceImpl.queryOrdersForRefresh": "import re\nfrom datetime import datetime\ndef is_valid(instance: dict) -> bool:\n    uuid_regex = re.compile(r'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')    \n    if instance.get('loginId') and not uuid_regex.match(instance['loginId']):\n        raise ValueError(f\"Invalid loginId format: {instance['loginId']}\") \n    if instance.get('state') is not None and (not isinstance(instance['state'], int) or instance['state'] < 0):\n        raise ValueError(f\"Invalid state value: {instance['state']}\")  \n    return True\n",
    "inside_payment.service.InsidePaymentServiceImpl.pay": "import re\n\ndef is_valid(instance: dict) -> bool:\n    # UUID regex pattern\n    uuid_pattern = re.compile(r'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')\n    \n    # Check userId\n    if 'userId' in instance and instance['userId'] is not None:\n        if not isinstance(instance['userId'], str):\n            raise ValueError(f\"userId must be a string, got {type(instance['userId'])}\")\n    \n    # Check orderId\n    if 'orderId' in instance and instance['orderId'] is not None:\n        if not isinstance(instance['orderId'], str):\n            raise ValueError(f\"orderId must be a string, got {type(instance['orderId'])}\")\n        if not uuid_pattern.match(instance['orderId']):\n            raise ValueError(f\"orderId must be a valid UUID, got {instance['orderId']}\")\n    \n    # Check tripId\n    if 'tripId' in instance and instance['tripId'] is not None:\n        if not isinstance(instance['tripId'], str):\n            raise ValueError(f\"tripId must be a string, got {type(instance['tripId'])}\")\n    \n    # Check price\n    if 'price' in instance and instance['price'] is not None:\n        if not isinstance(instance['price'], (str, float)):\n            raise ValueError(f\"price must be a string or float, got {type(instance['price'])}\")\n        try:\n            price_value = float(instance['price'])\n            if price_value <= 0:\n                raise ValueError(f\"price must be a positive number, got {price_value}\")\n        except ValueError:\n            raise ValueError(f\"price must be a valid float, got {instance['price']}\")\n    \n    return True\n\n",
    "travel2.service.TravelServiceImpl.queryByBatch": "import re\nfrom datetime import datetime\n\ndef is_valid(instance: dict) -> bool:\n    # Data Type Check\n    if not isinstance(instance.get('startPlace', ''), str):\n        raise ValueError(\"startPlace must be a string\")\n    if not isinstance(instance.get('endPlace', ''), str):\n        raise ValueError(\"endPlace must be a string\")\n    if not isinstance(instance.get('departureTime', ''), str):\n        raise ValueError(\"departureTime must be a string\")\n    \n    # Length Check\n    if instance.get('startPlace', '') == '':\n        raise ValueError(\"startPlace cannot be an empty string\")\n    if instance.get('endPlace', '') == '':\n        raise ValueError(\"endPlace cannot be an empty string\")\n    \n    # Format Check for departureTime\n    departure_time = instance.get('departureTime', '')\n    if departure_time:\n        # Check if it matches either 'YYYY-MM-DD HH:MM:SS' or 'YYYY-MM-DD'\n        if not re.match(r'^\\d{4}-\\d{2}-\\d{2}( \\d{2}:\\d{2}:\\d{2})?$', departure_time):\n            raise ValueError(\"departureTime must be in the format 'YYYY-MM-DD' or 'YYYY-MM-DD HH:MM:SS'\")\n        # Additional check to ensure the date is valid\n        try:\n            if ' ' in departure_time:\n                datetime.strptime(departure_time, '%Y-%m-%d %H:%M:%S')\n            else:\n                datetime.strptime(departure_time, '%Y-%m-%d')\n        except ValueError:\n            raise ValueError(\"departureTime must be a valid date\")\n    \n    # Consistency Check\n    if instance.get('startPlace', '').lower() == instance.get('endPlace', '').lower():\n        raise ValueError(\"startPlace and endPlace cannot be the same\")\n    \n    return True\n\n",
    "travel.service.TravelServiceImpl.queryByBatch": "import re\n\ndef is_valid(instance: dict) -> bool:\n    # Data Type Check\n    if not isinstance(instance.get('startPlace'), str):\n        raise ValueError(\"startPlace must be a string\")\n    if not isinstance(instance.get('endPlace'), str):\n        raise ValueError(\"endPlace must be a string\")\n    if not isinstance(instance.get('departureTime'), str):\n        raise ValueError(\"departureTime must be a string\")\n    \n    # Length Check\n    if instance.get('startPlace') == \"\":\n        raise ValueError(\"startPlace cannot be an empty string\")\n    if instance.get('endPlace') == \"\":\n        raise ValueError(\"endPlace cannot be an empty string\")\n    \n    # Consistency Check\n    if instance.get('startPlace') == instance.get('endPlace'):\n        raise ValueError(\"startPlace and endPlace cannot be the same\")\n    \n    # Format Check for departureTime\n    datetime_pattern = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}( \\d{2}:\\d{2}:\\d{2})?$\")\n    if not datetime_pattern.match(instance.get('departureTime')):\n        raise ValueError(\"departureTime must be in the format 'YYYY-MM-DD' or 'YYYY-MM-DD HH:MM:SS'\")\n    \n    return True\n\n",
    "rebook.service.RebookServiceImpl.rebook": "import re\nimport uuid\nfrom datetime import datetime\n\ndef is_valid(instance: dict) -> bool:\n    # Validate loginId (string, can be empty)\n    if not isinstance(instance.get('loginId', ''), str):\n        raise ValueError(\"loginId must be a string\")\n    \n    # Validate orderId (UUID)\n    order_id = instance.get('orderId', '')\n    try:\n        uuid.UUID(order_id)\n    except ValueError:\n        raise ValueError(\"orderId must be a valid UUID\")\n    \n    # Validate oldTripId (string, can be empty)\n    if not isinstance(instance.get('oldTripId', ''), str):\n        raise ValueError(\"oldTripId must be a string\")\n    \n    # Validate tripId (string, can be empty)\n    if not isinstance(instance.get('tripId', ''), str):\n        raise ValueError(\"tripId must be a string\")\n    \n    # Validate seatType (integer, within range 1-3)\n    seat_type = instance.get('seatType', 0)\n    if not isinstance(seat_type, int) or not (1 <= seat_type <= 3):\n        raise ValueError(\"seatType must be an integer within the range 1-3\")\n    \n    # Validate date (format YYYY-MM-DD)\n    date = instance.get('date', '')\n    try:\n        datetime.strptime(date, '%Y-%m-%d')\n    except ValueError:\n        raise ValueError(\"date must be in the format YYYY-MM-DD\")\n    \n    return True\n\n",
    "consign.service.ConsignServiceImpl.updateConsignRecord": "import re\nfrom datetime import datetime\n\ndef is_valid(instance: dict) -> bool:\n    # UUID regex pattern\n    uuid_pattern = re.compile(r'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')\n    \n    # Date and datetime format patterns\n    date_format = \"%Y-%m-%d\"\n    datetime_format = \"%Y-%m-%d %H:%M:%S\"\n    \n    # Phone number pattern (simple pattern for demonstration)\n    phone_pattern = re.compile(r'^\\d+$')\n    \n    # Data Type Check\n    if not isinstance(instance.get('id', ''), str):\n        raise ValueError(\"id must be a string\")\n    if not isinstance(instance.get('orderId', ''), str):\n        raise ValueError(\"orderId must be a string\")\n    if not isinstance(instance.get('accountId', ''), str):\n        raise ValueError(\"accountId must be a string\")\n    if not isinstance(instance.get('handleDate', ''), str):\n        raise ValueError(\"handleDate must be a string\")\n    if not isinstance(instance.get('targetDate', ''), str):\n        raise ValueError(\"targetDate must be a string\")\n    if not isinstance(instance.get('from', ''), str):\n        raise ValueError(\"from must be a string\")\n    if not isinstance(instance.get('to', ''), str):\n        raise ValueError(\"to must be a string\")\n    if not isinstance(instance.get('consignee', ''), str):\n        raise ValueError(\"consignee must be a string\")\n    if not isinstance(instance.get('phone', ''), str):\n        raise ValueError(\"phone must be a string\")\n    if not isinstance(instance.get('weight', 0.0), (float, int)):\n        raise ValueError(\"weight must be a float or int\")\n    if isinstance(instance.get('isWithin', False), bool):\n        raise ValueError(\"isWithin must be a boolean\")\n    \n    # Format Check\n    if instance.get('id') and not uuid_pattern.match(instance['id']):\n        raise ValueError(\"id must be a valid UUID\")\n    if instance.get('orderId') and not uuid_pattern.match(instance['orderId']):\n        raise ValueError(\"orderId must be a valid UUID\")\n    if instance.get('accountId') and not uuid_pattern.match(instance['accountId']):\n        raise ValueError(\"accountId must be a valid UUID\")\n    if instance.get('handleDate'):\n        try:\n            datetime.strptime(instance['handleDate'], date_format)\n        except ValueError:\n            raise ValueError(\"handleDate must be in YYYY-MM-DD format\")\n    if instance.get('targetDate'):\n        try:\n            datetime.strptime(instance['targetDate'], datetime_format)\n        except ValueError:\n            raise ValueError(\"targetDate must be in YYYY-MM-DD HH:MM:SS format\")\n    if instance.get('phone') and not phone_pattern.match(instance['phone']):\n        raise ValueError(\"phone must be a valid phone number\")\n    \n    # Range Check\n    if instance.get('weight', 0.0) < 0:\n        raise ValueError(\"weight must be a non-negative number\")\n    \n    # Consistency Check\n    if instance.get('handleDate') and instance.get('targetDate'):\n        handle_date = datetime.strptime(instance['handleDate'], date_format)\n        target_date = datetime.strptime(instance['targetDate'], datetime_format)\n        if target_date < handle_date:\n            raise ValueError(\"targetDate must be after or equal to handleDate\")\n    \n    return True\n\n",
    "consign.service.ConsignServiceImpl.queryByAccountId": "import re\nimport uuid\n\ndef is_valid(instance: dict) -> bool:\n    # Check if accountId is a valid UUID\n    account_id = instance.get('accountId')\n    if account_id:\n        try:\n            uuid_obj = uuid.UUID(account_id, version=4)\n            if str(uuid_obj) != account_id:\n                raise ValueError(f\"Invalid UUID format for accountId: {account_id}\")\n        except ValueError:\n            raise ValueError(f\"Invalid UUID format for accountId: {account_id}\")\n    \n    # Check if authorization follows the Bearer token format\n    authorization = instance.get('authorization')\n    if authorization:\n        if not re.match(r'^Bearer [A-Za-z0-9\\-_]+\\.[A-Za-z0-9\\-_]+\\.[A-Za-z0-9\\-_]+$', authorization):\n            raise ValueError(f\"Invalid Bearer token format for authorization: {authorization}\")\n    \n    return True\n", 
    "travelplan.service.TravelPlanServiceImpl.getCheapest": "import re\nfrom datetime import datetime\n\ndef is_valid(instance: dict) -> bool:\n    try:\n        # Data Type Check\n        if 'accountId' in instance and not isinstance(instance['accountId'], str):\n            raise ValueError(\"accountId must be a string\")\n        \n        if 'startPlace' in instance and not isinstance(instance['startPlace'], str):\n            raise ValueError(\"startPlace must be a string\")\n        \n        if 'endPlace' in instance and not isinstance(instance['endPlace'], str):\n            raise ValueError(\"endPlace must be a string\")\n        \n        if 'departureTime' in instance:\n            if not isinstance(instance['departureTime'], str):\n                raise ValueError(\"departureTime must be a string\")\n            # Format Check for datetime\n            try:\n                datetime.strptime(instance['departureTime'], '%Y-%m-%d %H:%M:%S')\n            except ValueError:\n                raise ValueError(\"departureTime must be in the format YYYY-MM-DD HH:MM:SS\")\n        \n        if 'content-length' in instance:\n            if not isinstance(instance['content-length'], int):\n                raise ValueError(\"content-length must be an integer\")\n            # Range Check for content-length\n            if instance['content-length'] < 0:\n                raise ValueError(\"content-length must be non-negative\")\n        \n        if 'Execution Time' in instance:\n            if not isinstance(instance['Execution Time'], int):\n                raise ValueError(\"Execution Time must be an integer\")\n            # Range Check for Execution Time\n            if instance['Execution Time'] < 0:\n                raise ValueError(\"Execution Time must be non-negative\")\n        \n        if 'status' in instance and not isinstance(instance['status'], int):\n            raise ValueError(\"status must be an integer\")\n        \n        if 'msg' in instance and not isinstance(instance['msg'], str):\n            raise ValueError(\"msg must be a string\")\n        \n        if 'data' in instance:\n            if not isinstance(instance['data'], list):\n                raise ValueError(\"data must be a list\")\n            for item in instance['data']:\n                if not isinstance(item, dict):\n                    raise ValueError(\"Each item in data must be a dictionary\")\n        \n        # Length Check for string fields\n        string_fields = ['accountId', 'startPlace', 'endPlace', 'accept', 'x-requested-with', 'user-agent', 'content-type', 'origin', 'referer', 'accept-encoding', 'cookie', 'forwarded', 'host', 'x-forwarded-proto', 'x-forwarded-port', 'x-forwarded-host']\n        for field in string_fields:\n            if field in instance and len(instance[field]) > 255:\n                raise ValueError(f\"{field} must be 255 characters or less\")\n        \n        return True\n    except Exception as e:\n        raise ValueError(f\"Validation error: {e}\")\n\n", 
    "travelplan.service.TravelPlanServiceImpl.getMinStation": "def is_valid(instance: dict) -> bool:\n    # Check if accountId is present and is a string\n    if 'accountId' in instance:\n        account_id = instance['accountId']\n        if not isinstance(account_id, str):\n            raise ValueError(f\"accountId must be a string, got {type(account_id).__name__}\")\n    \n    # If all checks pass\n    return True\n", 
    "execute.service.ExecuteServiceImpl.ticketCollect": "import re\n\ndef is_valid(instance: dict) -> bool:\n    # UUID regex pattern\n    uuid_pattern = re.compile(r'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')\n    \n    # Bearer token regex pattern (simplified for JWT)\n    bearer_pattern = re.compile(r'^Bearer [A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+$')\n    \n    # Validate orderId\n    orderId = instance.get('orderId')\n    if orderId is not None:\n        if not isinstance(orderId, str):\n            raise ValueError(f\"orderId must be a string, got {type(orderId).__name__}\")\n        if not uuid_pattern.match(orderId):\n            raise ValueError(f\"orderId '{orderId}' is not a valid UUID\")\n    \n    # Validate authorization\n    authorization = instance.get('authorization')\n    if authorization is not None:\n        if not isinstance(authorization, str):\n            raise ValueError(f\"authorization must be a string, got {type(authorization).__name__}\")\n        if not bearer_pattern.match(authorization):\n            raise ValueError(f\"authorization '{authorization}' is not a valid Bearer token\")\n    \n    return True\n", 
    "travelplan.service.TravelPlanServiceImpl.getQuickest": "def is_valid(instance: dict) -> bool:\n    # Check if orderId is present in the instance\n    if 'orderId' in instance:\n        orderId = instance['orderId']\n        \n        # Data Type Check: Ensure orderId is a string\n        if not isinstance(orderId, str):\n            raise ValueError(\"orderId must be a string.\")\n        \n        # Format Check: Ensure orderId is non-empty\n        if not orderId:\n            raise ValueError(\"orderId must be a non-empty string.\")\n        \n        # Length Check: Ensure orderId length is within a reasonable range\n        if not (1 <= len(orderId) <= 255):\n            raise ValueError(\"orderId length must be between 1 and 255 characters.\")\n    \n    # If all checks pass, return True\n    return True\n", 
    "execute.service.ExecuteServiceImpl.ticketExecute": "import re\nimport uuid\n\ndef is_valid(instance: dict) -> bool:\n    # Check if orderId is a valid UUID\n    order_id = instance.get('orderId')\n    if order_id:\n        try:\n            uuid_obj = uuid.UUID(order_id, version=4)\n        except ValueError:\n            raise ValueError(f\"Invalid orderId: {order_id}. It should be a valid UUID.\")\n    \n    # Check if authorization is a valid Bearer token\n    authorization = instance.get('authorization')\n    if authorization:\n        if not authorization.startswith(\"Bearer \"):\n            raise ValueError(f\"Invalid authorization: {authorization}. It should start with 'Bearer '.\")\n        \n        jwt_token = authorization[len(\"Bearer \"):]\n        jwt_pattern = re.compile(r'^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+$')\n        if not jwt_pattern.match(jwt_token):\n            raise ValueError(f\"Invalid JWT token in authorization: {jwt_token}. It should follow the JWT format.\")\n    \n    return True\n", 
    "consign.service.ConsignServiceImpl.queryByOrderId": "import re\nimport uuid\n\ndef is_valid(instance: dict) -> bool:\n    # Check if orderId is a valid UUID\n    order_id = instance.get('orderId')\n    if order_id:\n        try:\n            uuid_obj = uuid.UUID(order_id)\n        except ValueError:\n            raise ValueError(f\"Invalid UUID format for orderId: {order_id}\")\n    \n    # Check if authorization is a valid Bearer token\n    authorization = instance.get('authorization')\n    if authorization:\n        if not isinstance(authorization, str):\n            raise TypeError(f\"Authorization must be a string, got {type(authorization).__name__}\")\n        \n        bearer_pattern = r'^Bearer [A-Za-z0-9\\-_]+\\.[A-Za-z0-9\\-_]+\\.[A-Za-z0-9\\-_]+$'\n        if not re.match(bearer_pattern, authorization):\n            raise ValueError(f\"Invalid Bearer token format for authorization: {authorization}\")\n    \n    return True\n", 
    "cancel.service.CancelServiceImpl.calculateRefund": "import re\n\ndef is_valid(instance: dict) -> bool:\n    # Regular expression for UUID\n    uuid_regex = re.compile(r'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')\n    \n    # Regular expression for JWT (Bearer token)\n    jwt_regex = re.compile(r'^Bearer [A-Za-z0-9-_=]+\\.[A-Za-z0-9-_=]+\\.[A-Za-z0-9-_.+/=]*$')\n    \n    # Validate orderId\n    orderId = instance.get('orderId')\n    if orderId is not None:\n        if not isinstance(orderId, str):\n            raise ValueError(f\"orderId must be a string, got {type(orderId).__name__}\")\n        if not uuid_regex.match(orderId):\n            raise ValueError(f\"orderId '{orderId}' is not a valid UUID\")\n    \n    # Validate authorization\n    authorization = instance.get('authorization')\n    if authorization is not None:\n        if not isinstance(authorization, str):\n            raise ValueError(f\"authorization must be a string, got {type(authorization).__name__}\")\n        if not jwt_regex.match(authorization):\n            raise ValueError(f\"authorization '{authorization}' is not a valid Bearer token\")\n    \n    return True\n", 
    "cancel.service.CancelServiceImpl.cancel": "import re\n\ndef parse_headers(headers_str):\n    headers_dict = {}\n    headers_str = headers_str.strip('[]')\n    headers_pairs = headers_str.split(', ')\n    for pair in headers_pairs:\n        if ':' in pair:\n            key, value = pair.split(':', 1)\n            headers_dict[key.strip()] = value.strip()\n    return headers_dict\n\ndef is_valid(instance: dict) -> bool:\n    # UUID regex pattern\n    uuid_pattern = re.compile(r'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')\n    \n    # Validate accountId\n    account_id = instance.get('accountId')\n    if account_id is not None:\n        if not isinstance(account_id, str):\n            raise ValueError(f\"accountId must be a string, got {type(account_id).__name__}\")\n        if not uuid_pattern.match(account_id):\n            raise ValueError(f\"accountId '{account_id}' is not a valid UUID\")\n        if len(account_id) != 36:\n            raise ValueError(f\"accountId '{account_id}' does not have the correct length of 36 characters\")\n    \n    # Validate headers\n    headers = instance.get('headers')\n    if headers is not None:\n        if not isinstance(headers, str):\n            raise ValueError(f\"headers must be a string, got {type(headers).__name__}\")\n        try:\n            headers_dict = parse_headers(headers)\n            if not isinstance(headers_dict, dict):\n                raise ValueError(f\"headers must be a dictionary, got {type(headers_dict).__name__}\")\n        except Exception as e:\n            raise ValueError(f\"headers '{headers}' is not a valid headers string: {e}\")\n    \n    return True\n", 
    "user.service.impl.UserServiceImpl.getAllUsers": "import re\nimport uuid\n\ndef is_valid(instance: dict) -> bool:\n    # Helper functions for validation\n    def is_valid_uuid(value):\n        try:\n            uuid.UUID(str(value))\n            return True\n        except ValueError:\n            return False\n\n    def is_valid_email(value):\n        email_regex = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$'\n        return re.match(email_regex, value) is not None\n\n    def is_valid_jwt(value):\n        jwt_regex = r'^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+$'\n        return re.match(jwt_regex, value) is not None\n\n    # Validate authorization\n    if 'authorization' in instance and instance['authorization']:\n        if not isinstance(instance['authorization'], str):\n            raise ValueError(\"Authorization must be a string.\")\n        if not is_valid_jwt(instance['authorization'].split(\" \")[1]):\n            raise ValueError(\"Authorization must be a valid JWT token.\")\n\n    # Validate userId\n    if 'userId' in instance and instance['userId']:\n        if not is_valid_uuid(instance['userId']):\n            raise ValueError(\"userId must be a valid UUID.\")\n\n    # Validate userName\n    if 'userName' in instance and instance['userName']:\n        if not isinstance(instance['userName'], str):\n            raise ValueError(\"userName must be a string.\")\n\n    # Validate password\n    if 'password' in instance and instance['password']:\n        if not isinstance(instance['password'], str):\n            raise ValueError(\"password must be a string.\")\n\n    # Validate gender\n    if 'gender' in instance and instance['gender'] is not None:\n        if not isinstance(instance['gender'], int):\n            raise ValueError(\"gender must be an integer.\")\n        if instance['gender'] not in [0, 1]:\n            raise ValueError(\"gender must be either 0 or 1.\")\n\n    # Validate documentType\n    if 'documentType' in instance and instance['documentType'] is not None:\n        if not isinstance(instance['documentType'], int):\n            raise ValueError(\"documentType must be an integer.\")\n\n    # Validate documentNum\n    if 'documentNum' in instance and instance['documentNum']:\n        if not isinstance(instance['documentNum'], str):\n            raise ValueError(\"documentNum must be a string.\")\n\n    # Validate email\n    if 'email' in instance and instance['email']:\n        if not is_valid_email(instance['email']):\n            raise ValueError(\"email must be a valid email address.\")\n\n    return True\n", 
    "contacts.service.ContactsServiceImpl.findContactsByAccountId": "import re\nimport uuid\n\ndef is_valid(instance: dict) -> bool:\n    # UUID regex pattern\n    uuid_pattern = re.compile(r'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')\n    \n    # JWT regex pattern with optional \"Bearer \" prefix\n    jwt_pattern = re.compile(r'^(Bearer )?[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+$')\n    \n    # Validate accountId\n    account_id = instance.get('accountId')\n    if account_id and not uuid_pattern.match(account_id):\n        raise ValueError(f\"Invalid accountId: {account_id}\")\n    \n    # Validate authorization\n    authorization = instance.get('authorization')\n    if authorization and not jwt_pattern.match(authorization):\n        raise ValueError(f\"Invalid authorization token: {authorization}\")\n    \n    return True\n", 
    "foodsearch.service.FoodServiceImpl.getAllFood": "import re\n\ndef is_valid(instance: dict) -> bool:\n    # JWT token regex pattern\n    jwt_pattern = re.compile(r'^Bearer [A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+$')\n    \n    # Check if 'authorization' field is present and not empty\n    if 'authorization' in instance and instance['authorization']:\n        authorization = instance['authorization']\n        \n        # Validate the 'authorization' field format\n        if not jwt_pattern.match(authorization):\n            raise ValueError(f\"Invalid format for authorization: {authorization}\")\n    \n    # If all checks pass, return True\n    return True\n", 
    "assurance.service.AssuranceServiceImpl.getAllAssuranceTypes": "import re\n\ndef is_valid(instance: dict) -> bool:\n    # Check if authorization is a valid JWT\n    authorization = instance.get('authorization')\n    if authorization:\n        jwt_pattern = re.compile(r'^Bearer [A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+$')\n        if not jwt_pattern.match(authorization):\n            raise ValueError(f\"Invalid authorization: {authorization}. Must be a valid JWT Bearer token.\")\n    \n    return True\n",
    "contacts.service.ContactsServiceImpl.create":"import uuid\ndef is_valid(instance: dict) -> bool:\n    # Helper function to check if a string is a valid UUID\n    def is_valid_uuid(value):\n        try:\n            uuid.UUID(value)\n            return True\n        except ValueError:\n            return False\n\n    # Presence Check\n    required_fields = ['accountId', 'name', 'documentType', 'documentNumber', 'phoneNumber']\n    for field in required_fields:\n        if field not in instance or not instance[field]:\n            raise ValueError(f\"Field '{field}' is required and cannot be empty.\")\n\n    # Data Type Check and Format Check\n    \n    if not is_valid_uuid(instance['accountId']):\n        raise ValueError(\"Field 'accountId' must be a valid UUID.\")\n    \n    if not isinstance(instance['name'], str) or not instance['name'].strip():\n        raise ValueError(\"Field 'name' must be a non-empty string.\")\n    \n    if not isinstance(instance['documentType'], int):\n        raise ValueError(\"Field 'documentType' must be an integer.\")\n    \n    if not isinstance(instance['documentNumber'], str) or not instance['documentNumber'].strip():\n        raise ValueError(\"Field 'documentNumber' must be a non-empty string.\")\n    \n    if not isinstance(instance['phoneNumber'], str) or not instance['phoneNumber'].strip():\n        raise ValueError(\"Field 'phoneNumber' must be a non-empty string.\")\n    \n    # Vulnerability Check\n    suspicious_patterns = [\"<script>\", \"SELECT\", \"INSERT\", \"DELETE\", \"UPDATE\", \"--\", \";\", \"'\"]\n    for field in ['name', 'documentNumber', 'phoneNumber']:\n        for pattern in suspicious_patterns:\n            if pattern.lower() in instance[field].lower():\n                raise ValueError(f\"Field '{field}' contains potentially dangerous content.\")\n\n    return True"
}
{
    "auth.service.impl.TokenServiceImpl.getToken": "import re\n\ndef is_valid(instance: dict) -> bool:\n    # Validate username\n    username = instance.get('username')\n    if username is not None:\n        if not isinstance(username, str):\n            raise ValueError(\"Username must be a string.\")\n        if not re.match(r'^[a-zA-Z0-9_.]+$', username):\n            raise ValueError(\"Username must contain only alphanumeric characters, underscores, or dots.\")\n        if not (3 <= len(username) <= 30):\n            raise ValueError(\"Username must be between 3 and 30 characters long.\")\n    \n    # Validate password\n    password = instance.get('password')\n    if password is not None:\n        if not isinstance(password, str):\n            raise ValueError(\"Password must be a string.\")\n        if len(password) < 6:\n            raise ValueError(\"Password must be at least 6 characters long.\")\n    \n    # Validate verificationCode\n    verificationCode = instance.get('verificationCode')\n    if verificationCode is not None:\n        if not (isinstance(verificationCode, str) or isinstance(verificationCode, int)):\n            raise ValueError(\"Verification code must be a string or an integer.\")\n        if isinstance(verificationCode, str) and not re.match(r'^\\d{4}$', verificationCode):\n            raise ValueError(\"Verification code must be a 4-digit number if it is a string.\")\n        if isinstance(verificationCode, int) and not (1000 <= verificationCode <= 9999):\n            raise ValueError(\"Verification code must be a 4-digit number if it is an integer.\")\n    \n    return True\n\n",
    "preserveOther.service.PreserveOtherServiceImpl.preserve": "import re\nfrom uuid import UUID\nfrom datetime import datetime\n\ndef is_valid(instance: dict) -> bool:\n    try:\n        # Check UUIDs\n        if instance['accountId']:\n            UUID(instance['accountId'])\n        if instance['contactsId']:\n            UUID(instance['contactsId'])\n        \n        # Check tripId\n        if not isinstance(instance['tripId'], str) or not instance['tripId']:\n            raise ValueError(\"tripId must be a non-empty string\")\n        \n        # Check seatType\n        if not isinstance(instance['seatType'], int):\n            raise ValueError(\"seatType must be an integer\")\n        \n        # Check loginToken\n        if instance['loginToken'] is not None and not isinstance(instance['loginToken'], str):\n            raise ValueError(\"loginToken must be a string or null\")\n        \n        # Check date and handleDate\n        date_format = \"%Y-%m-%d\"\n        if instance['date']:\n            datetime.strptime(instance['date'], date_format)\n        if instance['handleDate']:\n            datetime.strptime(instance['handleDate'], date_format)\n        \n        # Check from and to\n        if not isinstance(instance['from'], str) or not instance['from']:\n            raise ValueError(\"from must be a non-empty string\")\n        if not isinstance(instance['to'], str) or not instance['to']:\n            raise ValueError(\"to must be a non-empty string\")\n        \n        # Check assurance and foodType\n        if not isinstance(instance['assurance'], int):\n            raise ValueError(\"assurance must be an integer\")\n        if not isinstance(instance['foodType'], int):\n            raise ValueError(\"foodType must be an integer\")\n        \n        # Check stationName, storeName, foodName\n        if instance['stationName'] is not None and not isinstance(instance['stationName'], str):\n            raise ValueError(\"stationName must be a string or null\")\n        if instance['storeName'] is not None and not isinstance(instance['storeName'], str):\n            raise ValueError(\"storeName must be a string or null\")\n        if instance['foodName'] is not None and not isinstance(instance['foodName'], str):\n            raise ValueError(\"foodName must be a string or null\")\n        \n        # Check foodPrice\n        if not isinstance(instance['foodPrice'], (int, float)) or instance['foodPrice'] < 0:\n            raise ValueError(\"foodPrice must be a non-negative float\")\n        \n        # Check consigneeName\n        if instance['consigneeName'] is not None and not isinstance(instance['consigneeName'], str):\n            raise ValueError(\"consigneeName must be a string or null\")\n        \n        # Check consigneePhone\n        if instance['consigneePhone'] is not None and not re.match(r'^\\d*$', instance['consigneePhone']):\n            raise ValueError(\"consigneePhone must be a string of digits or null\")\n        \n        # Check consigneeWeight\n        if not isinstance(instance['consigneeWeight'], (int, float)) or instance['consigneeWeight'] < 0:\n            raise ValueError(\"consigneeWeight must be a non-negative float\")\n        \n        # Check isWithin\n        if not isinstance(instance['isWithin'], bool):\n            raise ValueError(\"isWithin must be a boolean\")\n        \n        return True\n    except Exception as e:\n        raise ValueError(f\"Validation error: {e}\")\n\n",
    "preserve.service.PreserveServiceImpl.preserve": "import re\nfrom uuid import UUID\nfrom datetime import datetime\n\ndef is_valid(instance: dict) -> bool:\n    # Data Type Check\n    if not isinstance(instance['accountId'], str):\n        raise ValueError(\"accountId must be a string\")\n    if not isinstance(instance['contactsId'], str):\n        raise ValueError(\"contactsId must be a string\")\n    if not isinstance(instance['tripId'], str):\n        raise ValueError(\"tripId must be a string\")\n    if not isinstance(instance['seatType'], int):\n        raise ValueError(\"seatType must be an integer\")\n    if not isinstance(instance['loginToken'], (str, type(None))):\n        raise ValueError(\"loginToken must be a string or None\")\n    if not isinstance(instance['date'], str):\n        raise ValueError(\"date must be a string\")\n    if not isinstance(instance['from'], str):\n        raise ValueError(\"from must be a string\")\n    if not isinstance(instance['to'], str):\n        raise ValueError(\"to must be a string\")\n    if not isinstance(instance['assurance'], int):\n        raise ValueError(\"assurance must be an integer\")\n    if not isinstance(instance['foodType'], int):\n        raise ValueError(\"foodType must be an integer\")\n    if not isinstance(instance['stationName'], str):\n        raise ValueError(\"stationName must be a string\")\n    if not isinstance(instance['storeName'], str):\n        raise ValueError(\"storeName must be a string\")\n    if not isinstance(instance['foodName'], str):\n        raise ValueError(\"foodName must be a string\")\n    if not isinstance(instance['foodPrice'], float):\n        raise ValueError(\"foodPrice must be a float\")\n    if not isinstance(instance['handleDate'], (str, type(None))):\n        raise ValueError(\"handleDate must be a string or None\")\n    if not isinstance(instance['consigneeName'], (str, type(None))):\n        raise ValueError(\"consigneeName must be a string or None\")\n    if not isinstance(instance['consigneePhone'], (str, type(None))):\n        raise ValueError(\"consigneePhone must be a string or None\")\n    if not isinstance(instance['consigneeWeight'], float):\n        raise ValueError(\"consigneeWeight must be a float\")\n    if not isinstance(instance['isWithin'], bool):\n        raise ValueError(\"isWithin must be a boolean\")\n\n    # Code Check\n    try:\n        UUID(instance['accountId'])\n    except ValueError:\n        raise ValueError(\"accountId must be a valid UUID\")\n    \n    try:\n        UUID(instance['contactsId'])\n    except ValueError:\n        raise ValueError(\"contactsId must be a valid UUID\")\n    \n    if not re.match(r'^[A-Z]\\d+$', instance['tripId']):\n        raise ValueError(\"tripId must start with a letter followed by digits\")\n    \n    try:\n        datetime.strptime(instance['date'], '%Y-%m-%d')\n    except ValueError:\n        raise ValueError(\"date must be in YYYY-MM-DD format\")\n    \n    if instance['handleDate']:\n        try:\n            datetime.strptime(instance['handleDate'], '%Y-%m-%d')\n        except ValueError:\n            raise ValueError(\"handleDate must be in YYYY-MM-DD format\")\n\n    # Range Check\n    if not (1 <= instance['seatType'] <= 3):\n        raise ValueError(\"seatType must be between 1 and 3\")\n    \n    if instance['foodPrice'] < 0:\n        raise ValueError(\"foodPrice must be non-negative\")\n    \n    if instance['consigneeWeight'] < 0:\n        raise ValueError(\"consigneeWeight must be non-negative\")\n\n    # Format Check\n    if instance['consigneePhone'] and not re.match(r'^\\d+$', instance['consigneePhone']):\n        raise ValueError(\"consigneePhone must contain only digits\")\n\n    # Consistency Check\n    if instance['handleDate'] and instance['date']:\n        handle_date = datetime.strptime(instance['handleDate'], '%Y-%m-%d')\n        date = datetime.strptime(instance['date'], '%Y-%m-%d')\n        if handle_date > date:\n            raise ValueError(\"handleDate must be before or on the date\")\n\n    return True\n\n",
    "order.service.OrderServiceImpl.queryOrdersForRefresh": "import re\nfrom datetime import datetime\n\ndef is_valid(instance: dict) -> bool:\n    # Check if loginId is a valid UUID\n    uuid_regex = re.compile(r'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')\n    if instance.get('loginId') and not uuid_regex.match(instance['loginId']):\n        raise ValueError(f\"Invalid loginId: {instance['loginId']}\")\n\n    # Check if state is an integer\n    if instance.get('state') is not None and not isinstance(instance['state'], int):\n        raise ValueError(f\"State must be an integer: {instance['state']}\")\n\n    # Check if travelDateStart and travelDateEnd are valid dates and logically consistent\n    if instance.get('enableTravelDateQuery'):\n        travel_date_start = instance.get('travelDateStart')\n        travel_date_end = instance.get('travelDateEnd')\n        if travel_date_start and travel_date_end:\n            try:\n                start_date = datetime.strptime(travel_date_start, '%Y-%m-%d')\n                end_date = datetime.strptime(travel_date_end, '%Y-%m-%d')\n                if start_date > end_date:\n                    raise ValueError(\"travelDateStart must be before travelDateEnd\")\n            except ValueError as e:\n                raise ValueError(f\"Invalid travel dates: {e}\")\n\n    # Check if boughtDateStart and boughtDateEnd are valid dates and logically consistent\n    if instance.get('enableBoughtDateQuery'):\n        bought_date_start = instance.get('boughtDateStart')\n        bought_date_end = instance.get('boughtDateEnd')\n        if bought_date_start and bought_date_end:\n            try:\n                start_date = datetime.strptime(bought_date_start, '%Y-%m-%d')\n                end_date = datetime.strptime(bought_date_end, '%Y-%m-%d')\n                if start_date > end_date:\n                    raise ValueError(\"boughtDateStart must be before boughtDateEnd\")\n            except ValueError as e:\n                raise ValueError(f\"Invalid bought dates: {e}\")\n\n    # Check if state is within a valid range if enableStateQuery is True\n    if instance.get('enableStateQuery') and instance.get('state') is not None:\n        if not (0 <= instance['state'] <= 10):  # Assuming valid states are between 0 and 10\n            raise ValueError(f\"State must be between 0 and 10: {instance['state']}\")\n\n    return True\n\n",
    "other.service.OrderOtherServiceImpl.queryOrdersForRefresh": "import re\nfrom datetime import datetime\n\ndef is_valid(instance: dict) -> bool:\n    # Check if loginId is a valid UUID\n    uuid_regex = re.compile(r'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')\n    if instance.get('loginId') and not uuid_regex.match(instance['loginId']):\n        raise ValueError(f\"Invalid loginId format: {instance['loginId']}\")\n    \n    # Check if state is a non-negative integer\n    if instance.get('state') is not None and (not isinstance(instance['state'], int) or instance['state'] < 0):\n        raise ValueError(f\"Invalid state value: {instance['state']}\")\n    \n    # Check if travelDateStart and travelDateEnd are valid dates and travelDateStart <= travelDateEnd\n    date_format = \"%Y-%m-%d\"\n    if instance.get('travelDateStart') and instance.get('travelDateEnd'):\n        try:\n            travel_start = datetime.strptime(instance['travelDateStart'], date_format)\n            travel_end = datetime.strptime(instance['travelDateEnd'], date_format)\n            if travel_start > travel_end:\n                raise ValueError(\"travelDateStart must be before travelDateEnd\")\n        except ValueError as e:\n            raise ValueError(f\"Invalid travel date format: {e}\")\n    \n    # Check if boughtDateStart and boughtDateEnd are valid dates and boughtDateStart <= boughtDateEnd\n    if instance.get('boughtDateStart') and instance.get('boughtDateEnd'):\n        try:\n            bought_start = datetime.strptime(instance['boughtDateStart'], date_format)\n            bought_end = datetime.strptime(instance['boughtDateEnd'], date_format)\n            if bought_start > bought_end:\n                raise ValueError(\"boughtDateStart must be before boughtDateEnd\")\n        except ValueError as e:\n            raise ValueError(f\"Invalid bought date format: {e}\")\n    \n    # Check if enableTravelDateQuery, enableBoughtDateQuery, and enableStateQuery are booleans\n    for field in ['enableTravelDateQuery', 'enableBoughtDateQuery', 'enableStateQuery']:\n        if instance.get(field) is not None and not isinstance(instance[field], bool):\n            raise ValueError(f\"{field} must be a boolean\")\n    \n    return True\n\n",
    "inside_payment.service.InsidePaymentServiceImpl.pay": "import re\n\ndef is_valid(instance: dict) -> bool:\n    # UUID regex pattern\n    uuid_pattern = re.compile(r'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')\n    \n    # Check userId\n    if 'userId' in instance and instance['userId'] is not None:\n        if not isinstance(instance['userId'], str):\n            raise ValueError(f\"userId must be a string, got {type(instance['userId'])}\")\n    \n    # Check orderId\n    if 'orderId' in instance and instance['orderId'] is not None:\n        if not isinstance(instance['orderId'], str):\n            raise ValueError(f\"orderId must be a string, got {type(instance['orderId'])}\")\n        if not uuid_pattern.match(instance['orderId']):\n            raise ValueError(f\"orderId must be a valid UUID, got {instance['orderId']}\")\n    \n    # Check tripId\n    if 'tripId' in instance and instance['tripId'] is not None:\n        if not isinstance(instance['tripId'], str):\n            raise ValueError(f\"tripId must be a string, got {type(instance['tripId'])}\")\n    \n    # Check price\n    if 'price' in instance and instance['price'] is not None:\n        if not isinstance(instance['price'], (str, float)):\n            raise ValueError(f\"price must be a string or float, got {type(instance['price'])}\")\n        try:\n            price_value = float(instance['price'])\n            if price_value <= 0:\n                raise ValueError(f\"price must be a positive number, got {price_value}\")\n        except ValueError:\n            raise ValueError(f\"price must be a valid float, got {instance['price']}\")\n    \n    return True\n\n",
    "travel2.service.TravelServiceImpl.queryByBatch": "import re\nfrom datetime import datetime\n\ndef is_valid(instance: dict) -> bool:\n    # Data Type Check\n    if not isinstance(instance.get('startPlace', ''), str):\n        raise ValueError(\"startPlace must be a string\")\n    if not isinstance(instance.get('endPlace', ''), str):\n        raise ValueError(\"endPlace must be a string\")\n    if not isinstance(instance.get('departureTime', ''), str):\n        raise ValueError(\"departureTime must be a string\")\n    \n    # Length Check\n    if instance.get('startPlace', '') == '':\n        raise ValueError(\"startPlace cannot be an empty string\")\n    if instance.get('endPlace', '') == '':\n        raise ValueError(\"endPlace cannot be an empty string\")\n    \n    # Format Check for departureTime\n    departure_time = instance.get('departureTime', '')\n    if departure_time:\n        # Check if it matches either 'YYYY-MM-DD HH:MM:SS' or 'YYYY-MM-DD'\n        if not re.match(r'^\\d{4}-\\d{2}-\\d{2}( \\d{2}:\\d{2}:\\d{2})?$', departure_time):\n            raise ValueError(\"departureTime must be in the format 'YYYY-MM-DD' or 'YYYY-MM-DD HH:MM:SS'\")\n        # Additional check to ensure the date is valid\n        try:\n            if ' ' in departure_time:\n                datetime.strptime(departure_time, '%Y-%m-%d %H:%M:%S')\n            else:\n                datetime.strptime(departure_time, '%Y-%m-%d')\n        except ValueError:\n            raise ValueError(\"departureTime must be a valid date\")\n    \n    # Consistency Check\n    if instance.get('startPlace', '').lower() == instance.get('endPlace', '').lower():\n        raise ValueError(\"startPlace and endPlace cannot be the same\")\n    \n    return True\n\n",
    "travel.service.TravelServiceImpl.queryByBatch": "import re\n\ndef is_valid(instance: dict) -> bool:\n    # Data Type Check\n    if not isinstance(instance.get('startPlace'), str):\n        raise ValueError(\"startPlace must be a string\")\n    if not isinstance(instance.get('endPlace'), str):\n        raise ValueError(\"endPlace must be a string\")\n    if not isinstance(instance.get('departureTime'), str):\n        raise ValueError(\"departureTime must be a string\")\n    \n    # Length Check\n    if instance.get('startPlace') == \"\":\n        raise ValueError(\"startPlace cannot be an empty string\")\n    if instance.get('endPlace') == \"\":\n        raise ValueError(\"endPlace cannot be an empty string\")\n    \n    # Consistency Check\n    if instance.get('startPlace') == instance.get('endPlace'):\n        raise ValueError(\"startPlace and endPlace cannot be the same\")\n    \n    # Format Check for departureTime\n    datetime_pattern = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}( \\d{2}:\\d{2}:\\d{2})?$\")\n    if not datetime_pattern.match(instance.get('departureTime')):\n        raise ValueError(\"departureTime must be in the format 'YYYY-MM-DD' or 'YYYY-MM-DD HH:MM:SS'\")\n    \n    return True\n\n",
    "rebook.service.RebookServiceImpl.rebook": "import re\nimport uuid\nfrom datetime import datetime\n\ndef is_valid(instance: dict) -> bool:\n    # Validate loginId (string, can be empty)\n    if not isinstance(instance.get('loginId', ''), str):\n        raise ValueError(\"loginId must be a string\")\n    \n    # Validate orderId (UUID)\n    order_id = instance.get('orderId', '')\n    try:\n        uuid.UUID(order_id)\n    except ValueError:\n        raise ValueError(\"orderId must be a valid UUID\")\n    \n    # Validate oldTripId (string, can be empty)\n    if not isinstance(instance.get('oldTripId', ''), str):\n        raise ValueError(\"oldTripId must be a string\")\n    \n    # Validate tripId (string, can be empty)\n    if not isinstance(instance.get('tripId', ''), str):\n        raise ValueError(\"tripId must be a string\")\n    \n    # Validate seatType (integer, within range 1-3)\n    seat_type = instance.get('seatType', 0)\n    if not isinstance(seat_type, int) or not (1 <= seat_type <= 3):\n        raise ValueError(\"seatType must be an integer within the range 1-3\")\n    \n    # Validate date (format YYYY-MM-DD)\n    date = instance.get('date', '')\n    try:\n        datetime.strptime(date, '%Y-%m-%d')\n    except ValueError:\n        raise ValueError(\"date must be in the format YYYY-MM-DD\")\n    \n    return True\n\n",
    "consign.service.ConsignServiceImpl.updateConsignRecord": "import re\nfrom datetime import datetime\n\ndef is_valid(instance: dict) -> bool:\n    # UUID regex pattern\n    uuid_pattern = re.compile(r'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')\n    \n    # Date and datetime format patterns\n    date_format = \"%Y-%m-%d\"\n    datetime_format = \"%Y-%m-%d %H:%M:%S\"\n    \n    # Phone number pattern (simple pattern for demonstration)\n    phone_pattern = re.compile(r'^\\d+$')\n    \n    # Data Type Check\n    if not isinstance(instance.get('id', ''), str):\n        raise ValueError(\"id must be a string\")\n    if not isinstance(instance.get('orderId', ''), str):\n        raise ValueError(\"orderId must be a string\")\n    if not isinstance(instance.get('accountId', ''), str):\n        raise ValueError(\"accountId must be a string\")\n    if not isinstance(instance.get('handleDate', ''), str):\n        raise ValueError(\"handleDate must be a string\")\n    if not isinstance(instance.get('targetDate', ''), str):\n        raise ValueError(\"targetDate must be a string\")\n    if not isinstance(instance.get('from', ''), str):\n        raise ValueError(\"from must be a string\")\n    if not isinstance(instance.get('to', ''), str):\n        raise ValueError(\"to must be a string\")\n    if not isinstance(instance.get('consignee', ''), str):\n        raise ValueError(\"consignee must be a string\")\n    if not isinstance(instance.get('phone', ''), str):\n        raise ValueError(\"phone must be a string\")\n    if not isinstance(instance.get('weight', 0.0), (float, int)):\n        raise ValueError(\"weight must be a float or int\")\n    if not isinstance(instance.get('isWithin', False), bool):\n        raise ValueError(\"isWithin must be a boolean\")\n    \n    # Format Check\n    if instance.get('id') and not uuid_pattern.match(instance['id']):\n        raise ValueError(\"id must be a valid UUID\")\n    if instance.get('orderId') and not uuid_pattern.match(instance['orderId']):\n        raise ValueError(\"orderId must be a valid UUID\")\n    if instance.get('accountId') and not uuid_pattern.match(instance['accountId']):\n        raise ValueError(\"accountId must be a valid UUID\")\n    if instance.get('handleDate'):\n        try:\n            datetime.strptime(instance['handleDate'], date_format)\n        except ValueError:\n            raise ValueError(\"handleDate must be in YYYY-MM-DD format\")\n    if instance.get('targetDate'):\n        try:\n            datetime.strptime(instance['targetDate'], datetime_format)\n        except ValueError:\n            raise ValueError(\"targetDate must be in YYYY-MM-DD HH:MM:SS format\")\n    if instance.get('phone') and not phone_pattern.match(instance['phone']):\n        raise ValueError(\"phone must be a valid phone number\")\n    \n    # Range Check\n    if instance.get('weight', 0.0) < 0:\n        raise ValueError(\"weight must be a non-negative number\")\n    \n    # Consistency Check\n    if instance.get('handleDate') and instance.get('targetDate'):\n        handle_date = datetime.strptime(instance['handleDate'], date_format)\n        target_date = datetime.strptime(instance['targetDate'], datetime_format)\n        if target_date < handle_date:\n            raise ValueError(\"targetDate must be after or equal to handleDate\")\n    \n    return True\n\n"
}
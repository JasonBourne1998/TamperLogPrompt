{"auth.service.impl.TokenServiceImpl.getToken": "import re\n\ndef is_valid(instance: dict) -> bool:\n    # Presence Check\n    if 'username' not in instance or not instance['username']:\n        raise ValueError(\"Username is missing or empty.\")\n    if 'password' not in instance or not instance['password']:\n        raise ValueError(\"Password is missing or empty.\")\n    if 'verificationCode' not in instance or not instance['verificationCode']:\n        raise ValueError(\"Verification code is missing or empty.\")\n    \n    # Data Type Check\n    if not isinstance(instance['username'], str):\n        raise TypeError(\"Username must be a string.\")\n    if not isinstance(instance['password'], str):\n        raise TypeError(\"Password must be a string.\")\n    \n    # Format Check for username\n    if not re.match(r'^[a-zA-Z0-9_]+$', instance['username']):\n        raise ValueError(\"Username must be alphanumeric and can contain underscores.\")\n    \n    # Format Check for password\n    if len(instance['password']) == 0:\n        raise ValueError(\"Password cannot be empty.\")\n    \n    # Range Check for verificationCode\n    if not re.match(r'^\\d{4}$', str(instance['verificationCode'])):\n        raise ValueError(\"Verification code must be a 4-digit number.\")\n    \n    return True\n", 
"preserveOther.service.PreserveOtherServiceImpl.preserve": "import re\nfrom uuid import UUID\nfrom datetime import datetime\n\ndef is_valid(instance: dict) -> bool:\n    # Helper functions for validation\n    def is_uuid(value):\n        try:\n            UUID(value)\n            return True\n        except ValueError:\n            return False\n\n    def is_date(value):\n        try:\n            datetime.strptime(value, '%Y-%m-%d')\n            return True\n        except ValueError:\n            return False\n\n    # Presence Check\n    required_fields = ['accountId', 'contactsId', 'tripId', 'seatType', 'date', 'from', 'to']\n    for field in required_fields:\n        if field not in instance or instance[field] in [None, '']:\n            raise ValueError(f\"Field '{field}' is required and cannot be null or empty.\")\n\n    # Data Type Check and Format Check\n    if not is_uuid(instance['accountId']):\n        raise ValueError(\"Field 'accountId' must be a valid UUID.\")\n    if not is_uuid(instance['contactsId']):\n        raise ValueError(\"Field 'contactsId' must be a valid UUID.\")\n    if not isinstance(instance['seatType'], int):\n        raise ValueError(\"Field 'seatType' must be an integer.\")\n    if not is_date(instance['date']):\n        raise ValueError(\"Field 'date' must be in 'YYYY-MM-DD' format.\")\n    if 'foodPrice' in instance and not isinstance(instance['foodPrice'], (int, float)):\n        raise ValueError(\"Field 'foodPrice' must be a number.\")\n    if 'consigneeWeight' in instance and not isinstance(instance['consigneeWeight'], (int, float)):\n        raise ValueError(\"Field 'consigneeWeight' must be a number.\")\n\n    # Range Check\n    if instance['seatType'] < 0 or instance['seatType'] > 3:\n        raise ValueError(\"Field 'seatType' must be between 0 and 3.\")\n    if 'foodPrice' in instance and (instance['foodPrice'] < 0 or instance['foodPrice'] > 1000):\n        raise ValueError(\"Field 'foodPrice' must be between 0 and 1000.\")\n    if 'consigneeWeight' in instance and (instance['consigneeWeight'] < 0 or instance['consigneeWeight'] > 1000):\n        raise ValueError(\"Field 'consigneeWeight' must be between 0 and 1000.\")\n\n    # Vulnerability Check\n    # For simplicity, we assume that the input strings are safe and do not contain malicious content.\n    # In a real-world scenario, additional checks would be necessary to sanitize input strings.\n\n    return True\n", 
"preserve.service.PreserveServiceImpl.preserve": "import re\nfrom datetime import datetime\nfrom uuid import UUID\n\ndef is_valid(instance: dict) -> bool:\n    # Data Type Check\n    if not isinstance(instance.get('seatType'), int):\n        raise ValueError(\"seatType must be an integer\")\n    if not isinstance(instance.get('assurance'), int):\n        raise ValueError(\"assurance must be an integer\")\n    if not isinstance(instance.get('foodType'), int):\n        raise ValueError(\"foodType must be an integer\")\n    if not isinstance(instance.get('foodPrice'), (int, float)):\n        raise ValueError(\"foodPrice must be a float or integer\")\n    if not isinstance(instance.get('consigneeWeight'), (int, float)):\n        raise ValueError(\"consigneeWeight must be a float or integer\")\n\n    # Code Check and Format Check\n    try:\n        UUID(instance.get('accountId'))\n    except ValueError:\n        raise ValueError(\"accountId must be a valid UUID\")\n    \n    try:\n        UUID(instance.get('contactsId'))\n    except ValueError:\n        raise ValueError(\"contactsId must be a valid UUID\")\n    \n    if not re.match(r'^[A-Z]\\d{3,4}$', instance.get('tripId')):\n        raise ValueError(\"tripId must be in the format of a letter followed by 3 or 4 digits\")\n\n    # Range Check\n    if not (0 <= instance.get('foodPrice') <= 1000):\n        raise ValueError(\"foodPrice must be between 0 and 1000\")\n    if not (0 <= instance.get('consigneeWeight') <= 1000):\n        raise ValueError(\"consigneeWeight must be between 0 and 1000\")\n\n    # Format Check for date\n    try:\n        datetime.strptime(instance.get('date'), '%Y-%m-%d')\n    except ValueError:\n        raise ValueError(\"date must be in the format YYYY-MM-DD\")\n    \n    # Presence Check\n    required_fields = ['accountId', 'contactsId', 'tripId', 'date', 'from', 'to']\n    for field in required_fields:\n        if not instance.get(field):\n            raise ValueError(f\"{field} must not be empty\")\n\n    # Vulnerability Check\n    for field in ['accountId', 'contactsId', 'tripId', 'loginToken', 'date', 'from', 'to', 'stationName', 'storeName', 'foodName', 'handleDate', 'consigneeName', 'consigneePhone']:\n        if instance.get(field) and re.search(r'[<>]', instance.get(field)):\n            raise ValueError(f\"{field} contains potentially dangerous characters\")\n\n    return True\n", 
"order.service.OrderServiceImpl.queryOrdersForRefresh": "import re\n\ndef is_valid(instance: dict) -> bool:\n    # Data Type Check\n    if not isinstance(instance.get('loginId'), str):\n        raise ValueError(\"loginId must be a string.\")\n    \n    if instance.get('travelDateStart') is not None and not isinstance(instance.get('travelDateStart'), str):\n        raise ValueError(\"travelDateStart must be a string or None.\")\n    \n    if instance.get('travelDateEnd') is not None and not isinstance(instance.get('travelDateEnd'), str):\n        raise ValueError(\"travelDateEnd must be a string or None.\")\n    \n    if instance.get('boughtDateStart') is not None and not isinstance(instance.get('boughtDateStart'), str):\n        raise ValueError(\"boughtDateStart must be a string or None.\")\n    \n    if instance.get('boughtDateEnd') is not None and not isinstance(instance.get('boughtDateEnd'), str):\n        raise ValueError(\"boughtDateEnd must be a string or None.\")\n    \n    if not isinstance(instance.get('state'), int):\n        raise ValueError(\"state must be an integer.\")\n    \n    # Format Check\n    uuid_regex = re.compile(r'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')\n    if not uuid_regex.match(instance.get('loginId')):\n        raise ValueError(\"loginId must be a valid UUID.\")\n    \n    # Consistency Check\n    if instance.get('enableTravelDateQuery'):\n        if instance.get('travelDateStart') is None or instance.get('travelDateEnd') is None:\n            raise ValueError(\"Both travelDateStart and travelDateEnd must be provided if enableTravelDateQuery is True.\")\n    \n    if instance.get('enableBoughtDateQuery'):\n        if instance.get('boughtDateStart') is None or instance.get('boughtDateEnd') is None:\n            raise ValueError(\"Both boughtDateStart and boughtDateEnd must be provided if enableBoughtDateQuery is True.\")\n    \n    # Presence Check\n    if instance.get('loginId') is None:\n        raise ValueError(\"loginId must not be None.\")\n    \n    # Vulnerability Check\n    # Here we can add checks for common injection patterns if needed.\n    \n    return True\n", 
"other.service.OrderOtherServiceImpl.queryOrdersForRefresh": "import re\nfrom datetime import datetime\n\ndef is_valid(instance: dict) -> bool:\n    # Check if loginId is a valid UUID\n    uuid_regex = re.compile(\n        r'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$'\n    )\n    if not uuid_regex.match(instance.get('loginId', '')):\n        raise ValueError(f\"Invalid loginId: {instance.get('loginId')}\")\n\n    # Check if travelDateStart and travelDateEnd are valid dates and travelDateEnd is after travelDateStart\n    date_format = \"%Y-%m-%d\"\n    travel_date_start = instance.get('travelDateStart')\n    travel_date_end = instance.get('travelDateEnd')\n    if travel_date_start:\n        try:\n            travel_date_start = datetime.strptime(travel_date_start, date_format)\n        except ValueError:\n            raise ValueError(f\"Invalid travelDateStart: {travel_date_start}\")\n    if travel_date_end:\n        try:\n            travel_date_end = datetime.strptime(travel_date_end, date_format)\n        except ValueError:\n            raise ValueError(f\"Invalid travelDateEnd: {travel_date_end}\")\n    if travel_date_start and travel_date_end and travel_date_start > travel_date_end:\n        raise ValueError(\"travelDateEnd must be after travelDateStart\")\n\n    # Check if boughtDateStart and boughtDateEnd are valid dates and boughtDateEnd is after boughtDateStart\n    bought_date_start = instance.get('boughtDateStart')\n    bought_date_end = instance.get('boughtDateEnd')\n    if bought_date_start:\n        try:\n            bought_date_start = datetime.strptime(bought_date_start, date_format)\n        except ValueError:\n            raise ValueError(f\"Invalid boughtDateStart: {bought_date_start}\")\n    if bought_date_end:\n        try:\n            bought_date_end = datetime.strptime(bought_date_end, date_format)\n        except ValueError:\n            raise ValueError(f\"Invalid boughtDateEnd: {bought_date_end}\")\n    if bought_date_start and bought_date_end and bought_date_start > bought_date_end:\n        raise ValueError(\"boughtDateEnd must be after boughtDateStart\")\n\n    # Check if state is an integer\n    state = instance.get('state')\n    if not isinstance(state, int):\n        raise ValueError(f\"Invalid state: {state}\")\n\n    # Check if enableTravelDateQuery, enableBoughtDateQuery, enableStateQuery are booleans\n    for field in ['enableTravelDateQuery', 'enableBoughtDateQuery', 'enableStateQuery']:\n        if not isinstance(instance.get(field), bool):\n            raise ValueError(f\"Invalid {field}: {instance.get(field)}\")\n\n    return True\n", 
"inside_payment.service.InsidePaymentServiceImpl.pay": "import re\nimport uuid\n\ndef is_valid(instance: dict) -> bool:\n    # Presence Check\n    if 'orderId' not in instance or not instance['orderId']:\n        raise ValueError(\"orderId is required and cannot be null or empty.\")\n    if 'price' not in instance or not instance['price']:\n        raise ValueError(\"price is required and cannot be null or empty.\")\n    \n    # Format Check for UUID\n    try:\n        uuid.UUID(instance['orderId'])\n    except ValueError:\n        raise ValueError(f\"orderId {instance['orderId']} is not a valid UUID.\")\n    \n    # Data Type and Range Check for price\n    try:\n        price = float(instance['price'])\n        if price <= 0:\n            raise ValueError(\"price must be a positive number.\")\n    except ValueError:\n        raise ValueError(f\"price {instance['price']} is not a valid float.\")\n    \n    # Data Type Check for userId and tripId\n    if 'userId' in instance and not isinstance(instance['userId'], str):\n        raise ValueError(\"userId must be a string.\")\n    if 'tripId' in instance and not isinstance(instance['tripId'], str):\n        raise ValueError(\"tripId must be a string.\")\n    \n    # Vulnerability Check\n    for key in ['userId', 'orderId', 'tripId', 'price']:\n        if key in instance and isinstance(instance[key], str):\n            if re.search(r'[<>]', instance[key]):\n                raise ValueError(f\"{key} contains potentially malicious characters.\")\n    \n    return True\n", 
"travel2.service.TravelServiceImpl.queryByBatch": "import re\n\ndef is_valid(instance: dict) -> bool:\n    # Check if all required fields are present\n    required_fields = ['startPlace', 'endPlace', 'departureTime']\n    for field in required_fields:\n        if field not in instance:\n            raise ValueError(f\"Missing required field: {field}\")\n    \n    # Check if all fields are non-empty strings\n    for field in required_fields:\n        if not isinstance(instance[field], str) or not instance[field].strip():\n            raise ValueError(f\"Field {field} must be a non-empty string\")\n    \n    # Check the format of departureTime\n    departure_time = instance['departureTime']\n    if not re.match(r'^\\d{4}-\\d{2}-\\d{2}( \\d{2}:\\d{2}:\\d{2})?$', departure_time):\n        raise ValueError(f\"Field departureTime must be in format YYYY-MM-DD or YYYY-MM-DD HH:MM:SS\")\n    \n    return True\n", 
"travel.service.TravelServiceImpl.queryByBatch": "import re\nfrom datetime import datetime\n\ndef is_valid(instance: dict) -> bool:\n    # Check if all required fields are present\n    required_fields = ['startPlace', 'endPlace', 'departureTime']\n    for field in required_fields:\n        if field not in instance:\n            raise ValueError(f\"Missing required field: {field}\")\n    \n    # Data Type Check and Presence Check\n    for field in required_fields:\n        if not isinstance(instance[field], str):\n            raise TypeError(f\"Field {field} must be a string\")\n        if not instance[field].strip():\n            raise ValueError(f\"Field {field} cannot be empty\")\n    \n    # Format Check for departureTime\n    departure_time = instance['departureTime']\n    date_formats = [\"%Y-%m-%d %H:%M:%S\", \"%Y-%m-%d\"]\n    valid_format = False\n    for date_format in date_formats:\n        try:\n            datetime.strptime(departure_time, date_format)\n            valid_format = True\n            break\n        except ValueError:\n            continue\n    if not valid_format:\n        raise ValueError(f\"Field departureTime must be in format YYYY-MM-DD HH:MM:SS or YYYY-MM-DD\")\n    \n    # Vulnerability Check (basic check for XSS patterns)\n    xss_pattern = r\"<script.*?>.*?</script.*?>\"\n    for field in ['startPlace', 'endPlace', 'departureTime']:\n        if re.search(xss_pattern, instance[field], re.IGNORECASE):\n            raise ValueError(f\"Field {field} contains potential XSS pattern\")\n    \n    return True\n", 
"rebook.service.RebookServiceImpl.rebook": "import re\nimport uuid\nfrom datetime import datetime\n\ndef is_valid(instance: dict) -> bool:\n    # Presence Check (excluding loginId)\n    required_fields = ['orderId', 'oldTripId', 'tripId', 'seatType', 'date']\n    for field in required_fields:\n        if field not in instance or instance[field] in [None, '']:\n            raise ValueError(f\"Presence Check Failed: {field} should not be empty.\")\n    \n    # Format Check for UUID\n    try:\n        uuid.UUID(instance['orderId'])\n    except ValueError:\n        raise ValueError(\"Format Check Failed: orderId is not a valid UUID.\")\n    \n    # Format Check for oldTripId and tripId (assuming format is a letter followed by digits)\n    trip_id_pattern = re.compile(r'^[A-Z]\\d+$')\n    if not trip_id_pattern.match(instance['oldTripId']):\n        raise ValueError(\"Format Check Failed: oldTripId does not match the required format.\")\n    if not trip_id_pattern.match(instance['tripId']):\n        raise ValueError(\"Format Check Failed: tripId does not match the required format.\")\n    \n    # Range Check for seatType (assuming valid range is 1 to 3)\n    if not (1 <= instance['seatType'] <= 3):\n        raise ValueError(\"Range Check Failed: seatType is not within the valid range (1-3).\")\n    \n    # Format Check for date (ISO 8601 format)\n    try:\n        datetime.strptime(instance['date'], '%Y-%m-%d')\n    except ValueError:\n        raise ValueError(\"Format Check Failed: date is not in the correct format (YYYY-MM-DD).\")\n    \n    # Consistency Check (if any specific logic is required, it should be implemented here)\n    # For now, we assume oldTripId and tripId can be the same or different based on business logic\n    \n    return True\n", 
"consign.service.ConsignServiceImpl.updateConsignRecord": "import re\nfrom datetime import datetime\nimport uuid\n\ndef is_valid(instance: dict) -> bool:\n    # Presence Check\n    required_fields = ['orderId', 'accountId', 'handleDate', 'targetDate', 'from', 'to', 'consignee', 'phone', 'weight', 'isWithin']\n    for field in required_fields:\n        if not instance.get(field):\n            raise ValueError(f\"Field '{field}' should not be empty.\")\n    \n    # Data Type Check\n    if not isinstance(instance['orderId'], str):\n        raise TypeError(\"orderId must be a string.\")\n    if not isinstance(instance['accountId'], str):\n        raise TypeError(\"accountId must be a string.\")\n    if not isinstance(instance['handleDate'], str):\n        raise TypeError(\"handleDate must be a string.\")\n    if not isinstance(instance['targetDate'], str):\n        raise TypeError(\"targetDate must be a string.\")\n    if not isinstance(instance['from'], str):\n        raise TypeError(\"from must be a string.\")\n    if not isinstance(instance['to'], str):\n        raise TypeError(\"to must be a string.\")\n    if not isinstance(instance['consignee'], str):\n        raise TypeError(\"consignee must be a string.\")\n    if not isinstance(instance['phone'], str):\n        raise TypeError(\"phone must be a string.\")\n    if not isinstance(instance['weight'], (float, int)):\n        raise TypeError(\"weight must be a float or int.\")\n    # Removed the problematic boolean check for isWithin\n    \n    # Code Check\n    try:\n        uuid.UUID(instance['orderId'])\n        uuid.UUID(instance['accountId'])\n        if instance.get('id'):\n            uuid.UUID(instance['id'])\n    except ValueError:\n        raise ValueError(\"orderId, accountId, and id (if present) must be valid UUIDs.\")\n    \n    # Range Check\n    if instance['weight'] < 0:\n        raise ValueError(\"weight must be a non-negative number.\")\n    \n    # Format Check\n    try:\n        datetime.strptime(instance['handleDate'], '%Y-%m-%d')\n    except ValueError:\n        raise ValueError(\"handleDate must be in the format YYYY-MM-DD.\")\n    \n    try:\n        datetime.strptime(instance['targetDate'], '%Y-%m-%d %H:%M:%S')\n    except ValueError:\n        raise ValueError(\"targetDate must be in the format YYYY-MM-DD HH:MM:SS.\")\n    \n    if not re.match(r'^\\d+$', instance['phone']):\n        raise ValueError(\"phone must be numeric.\")\n    \n    # Consistency Check\n    handle_date = datetime.strptime(instance['handleDate'], '%Y-%m-%d')\n    target_date = datetime.strptime(instance['targetDate'], '%Y-%m-%d %H:%M:%S')\n    if target_date < handle_date:\n        raise ValueError(\"targetDate must be after or equal to handleDate.\")\n    \n    # Vulnerability Check\n    for field in ['orderId', 'accountId', 'handleDate', 'targetDate', 'from', 'to', 'consignee', 'phone']:\n        if '<script>' in instance[field].lower():\n            raise ValueError(f\"Field '{field}' contains potentially malicious content.\")\n    \n    return True\n"}